<!DOCTYPE HTML>
<html lang="en" class="light" dir="">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Distributed Cache - Ouinet Documentation</title>


        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../FontAwesome/css/all.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <link rel="stylesheet" href="../FontAwesome/css/all.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var body = document.querySelector('body');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
		<img src="../img/ouinet-logo.png" style="width:200px">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../index.html">Welcome</a></li><li class="chapter-item expanded "><a href="../intro/index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../build/index.html"><strong aria-hidden="true">2.</strong> Building from Source</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../build/docker.html"><strong aria-hidden="true">2.1.</strong> Docker</a></li><li class="chapter-item expanded "><a href="../build/vagrant.html"><strong aria-hidden="true">2.2.</strong> Vagrant</a></li><li class="chapter-item expanded "><a href="../build/testing.html"><strong aria-hidden="true">2.3.</strong> Testing</a></li></ol></li><li class="chapter-item expanded "><a href="../integration/index.html"><strong aria-hidden="true">3.</strong> Integration Guide</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../integration/examples.html"><strong aria-hidden="true">3.1.</strong> Example Apps</a></li></ol></li><li class="chapter-item expanded "><a href="../how/index.html"><strong aria-hidden="true">4.</strong> How it Works</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../how/components.html"><strong aria-hidden="true">4.1.</strong> Actors and Components</a></li><li class="chapter-item expanded "><a href="../how/content.html"><strong aria-hidden="true">4.2.</strong> Content Access Systems</a></li><li class="chapter-item expanded "><a href="../how/cache.html" class="active"><strong aria-hidden="true">4.3.</strong> Distributed Cache</a></li><li class="chapter-item expanded "><a href="../how/injectors.html"><strong aria-hidden="true">4.4.</strong> Injector Servers</a></li><li class="chapter-item expanded "><a href="../how/client.html"><strong aria-hidden="true">4.5.</strong> Client Library</a></li></ol></li><li class="chapter-item expanded "><a href="../contribute/index.html"><strong aria-hidden="true">5.</strong> Contribute</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ouinet Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>The Ouinet network uses a <em>distributed cache</em> as one of the methods of getting web content to users that try to access that content. If a web resource is fetched from the authoritative origin webserver on behalf of a user, in many cases the fetched resource can be used to satisfy future requests by different users trying to access the same content. If a user's device holds a copy of such suitable content, the Ouinet client can use peer-to-peer communication to transmit copies of this content to other users interested in the content; and conversely, if a user wants to access a certain web resource, the Ouinet client can use peer-to-peer communication to request a copy of the resource from a peer. In situations where user access to the centralized Ouinet injector infrastructure is unavailable, this technique provides a limited but useful alternative form of access to web content. If access to the injector infrastructure is unreliable or limited, the distributed cache can be used to satisfy resource requests wherever possible, allowing the Ouinet client to utilize the injectors only for those requests for which no alternative is available, reducing the load on the unreliable injectors and improving performance.</p>
<p>The caching of web resources is a standard functionality in the HTTP protocol. The HTTP protocol provides faculties by which an origin server can provide detailed instructions describing which resources are eligible for caching, which ones are not, the duration during which a resource can be cached, and requirements and limitations when caching the resource. HTTP clients implementing this system can satisfy HTTP requests by substituting an HTTP response stored in the cache, subject to the restrictions declared by the origin server, saving on network traffic and improving performance. HTTP client software such as web browsers commonly implement a cache for this purpose, which typically plays a major part in the performance characteristics of such software. The HTTP standard also describes caching HTTP proxies, which act as an performance-improving intermediary to a group of users by using a shared cache for all of them.</p>
<p>The Ouinet distributed cache is a variant implementation of such an HTTP cache, in which each Ouinet user has access to the combined cached resources of all Ouinet users worldwide. Each Ouinet client stores cached copies of resources they have recently accessed in the storage of their own device, and will use peer-to-peer communications to transfer these cached resources to other Ouinet clients that request access to them. From the viewpoint of a particular Ouinet user, the combined caches held by each Ouinet user worldwide function as a distributed filesystem containing more cached content than any one user device can realistically store.</p>
<p>Traditional HTTP caches are used in such a way that only a single party writes to, and reads from, the cache. The Ouinet distributed cache, on the other hand, forms a distributed filesystem that many different users can store resources in, and fetch resources from. This architectural difference comes with a number of complications that the Ouinet system needs to account for. With large numbers of people being able to participate in the distributed cache, the Ouinet software cannot assume that all these participants are necessarily trustworthy. When the Ouinet client requests a cached resource from some other Ouinet user using the peer-to-peer system, or sends some other Ouinet user a copy of a cached resource for their benefit, the Ouinet client must account for the possibility that their peer may have malicious intent. To accommodate this concern, the Ouinet distributed cache uses several systems to make it possible to cooperate on resource caching with untrusted peers.</p>
<p>When an HTTP client wishes to respond to an HTTP request by substituting a cached response, it needs to ensure that the stored cached response is in fact a legitimate response sent by the responsible origin server to the associated request. In a traditional HTTP cache operated by a single party, this is a trivial requirement, for the cache software will only store a cached response after receiving it from the responsible origin server, which means the cache storage serves as a trusted repository of cached content. In the Ouinet distributed cache, on the other hand, cached resources may be supplied by untrusted peers, and there is no obvious way in which the receiving party can verify that this response is a legitimate one; a malicious peer could easily create a forged response, add it to its local cache storage, and send it to its peers. This behavior is a threat that the Ouinet client needs to be able to guard against.</p>
<p>To avoid this problem, the Ouinet system makes use of trusted injector servers, charged with the authority of creating resource cache entries whose legitimacy can be verified by Ouinet clients. When these injector servers fetch an HTTP resource on behalf of a user, they determine if the resulting response is eligible for caching; if it is, they will then create a cryptographic signature covering the response, which enables the peer-to-peer distribution of the cached resource in the distributed cache. By verifying this signature, clients can confirm that a cached resource has been deemed legitimate by a trusted injector server.</p>
<p>A different security concern when using an HTTP cache shared between large numbers of people lies in the confidentiality of privacy-sensitive data communicated using web resources. Some HTTP responses contain private information intended only for the recipient, and nobody else; to avoid compromising confidentiality, responses with this characteristic must not be shared using the distributed cache. The Ouinet system therefore needs to be able to recognize confidential responses, and mark them as ineligible for caching.</p>
<p>The HTTP protocol contains functionality by which origin servers can specify resources that are ineligible for caching, or ineligible for public caching, on the grounds of confidentiality, which in theory should imply that recognizing confidential responses should be a simple matter. Unfortunately, origin servers in practice do not always adhere to this protocol very accurately. It is reasonably common for origin servers to serve confidential resources while failing to mark them as such, in which case it is critical that the Ouinet system is able to recognize the confidentiality of the resource by some other means. Much more common still is the reverse situation, in which a non-confidential resource is marked as ineligible for caching on confidentiality grounds by the origin server, typically for commercial reasons. If the Ouinet system were to accept these judgements uncritically, the amount of resources eligible for caching would be sharply limited, reducing the utility of the distributed cache considerably. To avoid both problems, the Ouinet system uses a heuristic analysis to recognize cases where the origin-supplied cache-eligibility judgement is misleading.</p>
<p>The remainder of this section describes the details of the operation of the Ouinet distributed cache system. It details the exact data stored in the cache, and its interpretation; the system used for signing and verification of cached resources; and finally, it describes the methods and protocols by which different actors in the Ouinet network may exchange cached resources with each other.</p>
<h2 id="cache-structure"><a class="header" href="#cache-structure">Cache structure</a></h2>
<p>The Ouinet distributed cache conceptually consists of a repository of cached web resources. Each such cached resource takes the form of a record referred to as a <em>cache entry</em>. A cache entry represents a single HTTP response suitable for using as a cached reply, along with assorted metadata that makes it possible to verify the legitimacy of the cached response, check the response for expiracy or being superceded, and assess its usability. Cache entries are created by the Ouinet injector servers, transmitted from injector servers to Ouinet clients, stored on client devices, and shared between different clients using peer-to-peer systems.</p>
<p>A cache entry is a data structure consisting of the resource URI, the HTTP response headers, the HTTP response body, additional metadata added by the Ouinet injector, and a cryptographic signature asserting the legitimacy of the cache entry.</p>
<p>Clients that participate in the distributed cache store a collection of such cache entries on their device's local storage, and can get access to many more cache entries using the peer-to-peer network. When satisfying an HTTP request, they can search the distributed cache for any cache entries with an URI matching the one in the HTTP request, checking them for validity, and substituting the cached resource as an HTTP response.</p>
<h3 id="cache-entry-construction"><a class="header" href="#cache-entry-construction">Cache entry construction</a></h3>
<p>Cache entries are created by the Ouinet injector servers. Injector servers can create a cache entry by requesting an HTTP resource on behalf of a user, checking the response for cache eligibility, adding necessary metadata, and signing the resulting package.</p>
<p>Cache entries are identified by their resource URI; when a Ouinet client seeks to resolve an HTTP request from the distributed cache, it can use any cache entry whose resource URI matches the URI in the HTTP request. For this behavior to work as expected without causing problems, the injector servers should avoid sending multiple HTTP requests for a particular resource URI that are interpreted by the responsible origin server as having different request semantics; this can happen, for example, if the origin server chooses to vary its response based on the user's user agent settings, which are communicated as part of the HTTP request using HTTP headers. In this scenario, the distributed cache would likely end up storing multiple semantically different responses for this resource. The Ouinet client would not be able to distinguish between the competing cache entries, on account of them using the same resource URI, causing confusion and unpredictable behavior.</p>
<p>To avoid this problem, the injector servers will not create cache entries based on HTTP responses received after forwarding arbitrary HTTP requests. Instead, when attemping to create a cache entry, the injector servers will only use a single predictable HTTP request for each resource URI, which is allowed to vary only on a carefully selected list of characteristics known not to affect the request semantics. For similar reasons, when creating a cache entry, the injector servers will remove all metadata from the HTTP response whose semantics are likely to change with different requests for the same resource. Together, these two procedures are referred to as <em>resource canonicalization</em>.</p>
<p>Separately from the above, the distributed cache mechanism also needs to check whether a particular HTTP response is eligible for storing in the cache at all. Many HTTP resources should not be stored in any cache, because their content changes frequently and unpredictably, or because their content is personalized specifically for the user requesting the resource; this eligibility is typically specified in HTTP response headers. In addition, clients sometimes wish to send an HTTP request without the limitations enforced by the resource canonicalization system; in such cases, the resource can neither be retrieved from the distributed cache, nor stored in it.</p>
<p>The process for constructing a cache entry and storing it in the distributed cache is a procedure that incorporates all these systems. It consists of the following steps:</p>
<ul>
<li>The Ouinet client wishes to perform an HTTP request.</li>
<li>The Ouinet client checks whether the request is eligible for caching. If it is not, the distributed cache subsystem is not used.</li>
<li>The Ouinet client contacts an injector server, and asks it to create a cache entry corresponding to the HTTP request.</li>
<li>The injector server canonicalizes the HTTP request.</li>
<li>The injector server sends the canonicalized request to the responsible origin server, and awaits a response.</li>
<li>The injector server canonicalizes the HTTP response.</li>
<li>The injector server adds metadata to the HTTP response in the form of additional HTTP headers, describing the characteristics of the cache entry.</li>
<li>The injector server creates a cryptographic signature for the cache entry.</li>
<li>The injector server sends the modified HTTP response to the client, along with the signature.</li>
<li>The Ouinet client checks whether the response is eligible for caching. If it is, it stores the combination of the HTTP response and the signature to the distributed cache.</li>
<li>The Ouinet client resolves the HTTP request, whether or not it was also stored in the distributed cache.</li>
</ul>
<p>The exact communication between the Ouinet client and the injector server, as well as the details of the cryptographic signatures used in cache entry construction, are described in later sections. Other details are described below.</p>
<h4 id="resource-canonicalization"><a class="header" href="#resource-canonicalization">Resource canonicalization</a></h4>
<p>When sending an HTTP request to an origin server for the purpose of creating a cache entry, the Ouinet injector creates a minimal canonical HTTP request based on the resource URI as well as a small number of request headers derived from the HTTP request sent by the Ouinet client. The <em>canonical request</em> also contains neutral generic values for certain headers that many origin servers expect to be present.</p>
<p>This canonical HTTP request takes the form of an HTTP/1.1 request, with a request target and <code>Host:</code> header derived from the resource URI in the standard way. The canonical request also contains the following headers:</p>
<ul>
<li><code>Accept: */*</code></li>
<li><code>Accept-Encoding: </code></li>
<li><code>DNT: 1</code></li>
<li><code>Upgrade-Insecure-Requests: 1</code></li>
<li><code>User-Agent: Mozilla/5.0 (Windows NT 10.0; rv:68.0) Gecko/20100101 Firefox/68.0</code></li>
<li><code>Origin:</code> whatever value is present in the client request, if any, or absent otherwise</li>
<li><code>From:</code> whatever value is present in the client request, if any, or absent otherwise</li>
</ul>
<p>This canonical request is sent to the origin server, and the accompanying response used to create a cache entry.</p>
<p>After receiving a reply to this canonical request from the origin server, the injector server removes from the response all HTTP headers that are likely to describe details of the individual request that was performed, rather than the resource that was requested. It also removes headers that describe characteristics that do not apply to a cached version of the resource. This modified form of the HTTP response is then known as the <em>canonical response</em>.</p>
<p>The canonical response is created by removing from the origin response all headers, except for those that are explicitly allowed. The canonical response contains the following headers, insofar as they are present in the origin response:</p>
<ul>
<li><code>Server</code></li>
<li><code>Retry-After</code></li>
<li><code>Content-Type</code></li>
<li><code>Content-Encoding</code></li>
<li><code>Content-Language</code></li>
<li><code>Digest</code></li>
<li><code>Accept-Ranges</code></li>
<li><code>ETag</code></li>
<li><code>Age</code></li>
<li><code>Date</code></li>
<li><code>Expires</code></li>
<li><code>Via</code></li>
<li><code>Vary</code></li>
<li><code>Location</code></li>
<li><code>Cache-Control</code></li>
<li><code>Warning</code></li>
<li><code>Last-Modified</code></li>
<li><code>Access-Control-Allow-Origin</code></li>
<li><code>Access-Control-Allow-Credentials</code></li>
<li><code>Access-Control-Allow-Methods</code></li>
<li><code>Access-Control-Allow-Headers</code></li>
<li><code>Access-Control-Max-Age</code></li>
<li><code>Access-Control-Expose-Headers</code></li>
</ul>
<p>All headers in the origin response that are not on this list are removed from the canonical response.</p>
<h4 id="added-metadata"><a class="header" href="#added-metadata">Added metadata</a></h4>
<p>When a Ouinet injector has created a canonical response for a newly constructed cache entry, it then adds a series of headers that describe the properties of the cache entry itself. These headers aid a Ouinet client receiving the cache entry to interpret the cache entry correctly. These headers are stored in the cache entry as part of the HTTP response headers.</p>
<p>The Ouinet injector adds the following headers to the cache entry:</p>
<ul>
<li><code>X-Ouinet-Version</code>: This describes the version of the Ouinet distributed cache storage format. This document describes the distributed cache storage format version <strong>4</strong>.</li>
<li><code>X-Ouinet-URI</code>: Contains the URI of the resource described by this cache entry.</li>
<li><code>X-Ouinet-Injection</code>: This describes a unique ID assigned to this cache entry, allowing a receiver to refer unambiguously to this specific cache entry, as well as the time at which the cache entry was created. Encoded as <code>X-Ouinet-Injection: id=&lt;string&gt;,ts=&lt;timestamp&gt;</code>, where <code>&lt;string&gt;</code> is a string containing only alphanumeric characters, dashes, and underscores; and <code>&lt;timestamp&gt;</code> is an integer value, representing a timestamp expressed as the number of seconds since 1970-01-01 00:00:00 UTC.</li>
</ul>
<p>The Ouinet injector furthermore adds headers related to the cryptographic signature used to verify the legitimacy of the cache entry. This is described in more detail in the <a href="#signatures">Signatures</a> section.</p>
<h4 id="cache-eligibility"><a class="header" href="#cache-eligibility">Cache eligibility</a></h4>
<p>The distributed cache system makes a determination, for each resource request, whether that resource is eligible for caching. This process takes place in two parts. When the client is preparing to send an HTTP request, it first determines whether the request is one that can, in principle, be cached; if this is not the case, the Ouinet client does not use the distributed cache system at all when satisfying this request. If the request is eligible for caching, the request can be sent to an injector server, which --all going well-- will reply with a cache entry that can be stored in the distributed cache. The client then makes a second determination whether the response is also eligible for caching. If it is not, the resource request is completed successfully, but the cache entry is not stored.</p>
<p>The Ouinet client currently considers an HTTP request to be eligible for caching if it uses the GET HTTP access method, and moreover the resource URI is not on a configurable blacklist of resources that are never eligible. This is certainly an overestimate for general browsing; for one example, there are many web resources that can only be accessed after authenticating using HTTP authentication, or only after authenticating using some cookie-based authentication scheme. This scheme therefore relies on careful configuration of the resource blacklist for it to work well in practice. Improving this heuristic remains a fertile area for future improvement.</p>
<p>To determine whether an HTTP response is eligible for storing in the distributed cache, Ouinet uses a variant of the procedure described in <a href="https://tools.ietf.org/html/rfc7234#section-3">RFC 7234, section 3</a>. This RFC describes a procedure determining whether an HTTP response is allowed to be stored in a cache, based on the characteristics of the cache, expiracy information communicated in the response headers, and the <code>Cache-Control</code> header. The Ouinet distributed cache follows this procedure as written, with two major exceptions:</p>
<ul>
<li>The Ouinet distributed cache will only store HTTP responses with an status code of 200 (OK), 301 (Moved Permanently), 302 (Found), or 307 (Temporary Redirect). The Ouinet project does not wish to store error status pages in the distributed cache.</li>
<li>If the HTTP response contains the <code>Cache-Control: private</code> clause, the Ouinet client will use a heuristic analysis to verify that this clause is warranted.</li>
</ul>
<p>Many origin servers will declare a <code>Cache-Control: private</code> clause on resources that are not really private in reality, but which the origin server wishes to personalize in a non-confidential way for each request. For such resources, the Ouinet client ideally wishes to store the cache entry as if the <code>Cache-Control: private</code> clause was absent, but avoid satisfying requests for this resource using the distributed cache unless no other methods for accessing the resource are available. To determine whether the <code>Cache-Control: private</code> clause is used with good reason, Ouinet uses the following procedure:</p>
<ul>
<li>If the HTTP request uses an HTTP method other than GET, the <code>Cache-Control: private</code> clause is warranted.</li>
<li>If the resource URI contains a query string (that is, if it contains a question mark character), the <code>Cache-Control: private</code> clause is warranted.</li>
<li>If the HTTP request contains any header fields that might contain confidential information, the <code>Cache-Control: private</code> clause is warranted.</li>
<li>If neither of the above applies, the <code>Cache-Control: private</code> is unwarranted, and the cache entry is eligible for storage in the distributed cache.</li>
</ul>
<p>For the purposes of this procedure, the following HTTP request headers are considered to never contain confidential information:</p>
<ul>
<li><code>Host</code></li>
<li><code>User-Agent</code></li>
<li><code>Cache-Control</code></li>
<li><code>Accept</code></li>
<li><code>Accept-Language</code></li>
<li><code>Accept-Encoding</code></li>
<li><code>From</code></li>
<li><code>Origin</code></li>
<li><code>Keep-Alive</code></li>
<li><code>Connection</code></li>
<li><code>Referer</code></li>
<li><code>Proxy-Connection</code></li>
<li><code>X-Requested-With</code></li>
<li><code>Upgrade-Insecure-Requests</code></li>
<li><code>DNT</code></li>
</ul>
<p>Any headers not on this list are considered to potentially contain confidential information. If any header not on this list is present in the HTTP request, the <code>Cache-Control: private</code> clause is considered to be warranted.</p>
<h3 id="validity-checking"><a class="header" href="#validity-checking">Validity checking</a></h3>
<p>When a Ouinet client wishes to use a cache entry stored in the distributed cache to satisfy a resource request, it must first verify that the cache entry has not expired, is unusable for some other reason, or needs revalidation from the origin server. To make this determination, the Ouinet client largely follows the procedure described in <a href="https://tools.ietf.org/html/rfc7234#section-4">RFC 7234, section 4</a>. It deviates from this procedure on two important points, however.</p>
<p>The procedure described in this RFC allows a client to use a cache entry that is expired, in certain cases where the client is unable to connect to the responsible origin server to request an up-to-date resource. However, this behavior is bound to strict conditions, and the great majority of origin servers specify <code>Cache-Control</code> clauses that disallow this behavior, making this mechanism of sharply limited practical value.</p>
<p>Because the Ouinet project aims to provide some limited form of access to web resources even in cases where no access to the responsible origin server can be arranged, the Ouinet client is willing to use expired cache entries in cases where the procedure described in the RFC specifically disallows this behavior. When the Ouinet client cannot establish contact to the responsible origin server in any way --either directly, or by using an injector server as an intermediary-- and when all cache entries for the resource the client has access to are expired, the client will use this cache entry to satisfy the resource request, despite any <code>Cache-Control</code> clauses that would disallow this. This ensures that the Ouinet client will provide some limited access to the resource, if this is at all possible.</p>
<p>For similar reasons, the Ouinet client is willing to use cache entries that have the <code>Cache-Control: private</code> clause set, if no other options are available. As described in the previous section, cache entries with this clause set should only be used by the client as an option of last resort. The Ouinet client treats such cache entries equivalently to cache entries that have expired.</p>
<h3 id="signatures"><a class="header" href="#signatures">Signatures</a></h3>
<p>When an injector server creates a cache entry for distribution, it also creates a cryptographic signature of this cache entry using a private key specific to the injector server, or group of injector servers to which the injector server belongs. By verifying this signature, recipients of the cache entry can confirm that the cache entry was created and retrieved from an origin server by one of the injector servers, which hold a trusted position in the Ouinet network. This is important particularly when retrieving the cache entry via peer-to-peer communication with another client, as the presence of the signature makes it impossible for a malicious client to forge a cache entry.</p>
<p>The cache entry signature is computed as a signature over the cache entry as created by the injector server, consisting of the response content, the canonicalized response headers, and the added metadata described in the <a href="#cache-entry-construction">Cache entry construction</a> section. A Ouinet client receiving a copy of a cache entry from another client using the peer-to-peer cache system, or from some external source, should verify this signature before using the cache entry to satisfy requests, and reject the cache entry if the signature is invalid. If a Ouinet client receives a cache entry directly from a Ouinet injector server, it may choose to skip this verification, as long as the client has previously confirmed the identity of the injector server to which it is connected.</p>
<p>The requirement for a Ouinet client to verify the cache entry signature before using the cache entry --and, in particular, to avoid using any of the data in the cache entry before having performed this verification-- has unfortunate consequences when a client tries to fetch a cache entry that is large enough that the download process takes significant amounts of time. When a client wishes to download a cached copy of a large resource, such as a large media file, the client needs to download the entire resource, verify the signature, and only then start doing something useful with the resource. Many web applications contain functionality to start making use of a resource while the process to download that resource is still ongoing; examples include the streaming of audio and video content, and the incremental loading of large images. The signature verification process as described above would greatly limit this functionality, for the application could only start using such content after the signature has been verified, which can only happen after the entire resource download has completed.</p>
<p>To mitigate this limitation, the distributed cache can make use of an alternative signature scheme in which the injector server can produce signatures for individual fragments of a resource. When using this scheme, the injector server will split up a resource into a series of fragments, and generate a separate signature for each fragment, including enough metadata that a client can verify that these fragments form a contiguous resource. A client receiving a cache entry using such fragmented signatures can verify the signature of each fragment as it comes in, and incrementally start loading the content present in an individual fragment once its signature has been verified. A client can also deliberately fetch selected fragments of a cache entry and verify their legitimacy, which is useful if the client wishes to access only parts of a larger resource.</p>
<h4 id="signature-computation"><a class="header" href="#signature-computation">Signature computation</a></h4>
<p>To compute a signature for a complete cache entry, the Ouinet distributed cache uses a version of the format specified in the <a href="https://datatracker.ietf.org/doc/html/draft-cavage-http-signatures-12">Signing HTTP Messages</a> draft. This protocol specifies a way of computing signatures on HTTP messages that are robust to the transformations that frequently happen to HTTP messages in transit. This robustness makes it possible to send a signed HTTP message as part of an HTTP session, performing transit-related manipulations such as the addition of a <code>Connection: keep-alive</code> header where necessary, without causing the signature to become invalid.</p>
<p>Signing HTTP Messages signatures consist of a signature over a selected subset of the headers in an HTTP message; the distributed cache uses this system by including all headers in the signature that are part of the cache entry, as constructed per the process described in the <a href="#cache-entry-construction">Cache entry construction</a> section. By design, these headers do not include any headers that might vary with different ways in which a cache entry might be communicated between peers, such as the <code>Connection</code>, <code>Transfer-Encoding</code>, and <code>Content-Length</code> headers.</p>
<p>The signature used by the distributed cache must cover certain information that is not stored in HTTP headers in the strictest sense. Most obviously, this includes the body of the HTTP response. To ensure that the body is covered by the cache entry signature, the injector server adds a <code>Digest</code> header to the cache entry, containing a cryptographic hash of the response body. This <code>Digest</code> header is then included in the headers covered by the signature.</p>
<p>In addition, Signing HTTP Messages signatures can include pieces of information regarding an HTTP message that are not stored in any HTTP headers, by including key/value pairs in the signature calculation as if they were HTTP headers. The distributed cache uses these <em>pseudo-headers</em> to describe the HTTP status code, which is not a header, as well as the time at which the signature was created.</p>
<p>To compute the cache entry signature, the injector server uses the following procedure:</p>
<ul>
<li>Construct a cache entry as described in the <a href="#cache-entry-construction">Cache entry construction</a> section, containing a canonicalized HTTP response with added headers containing further metadata;</li>
<li>Add a <code>Digest</code> header, containing a cryptographic hash of the response body;</li>
<li>Add an <code>X-Ouinet-Data-Size</code> header, containing the length of the response body;</li>
<li>Add a <code>(created)</code> pseudo-header, containing the time at which the signature was created, expressed as the number of seconds since 1970-01-01 00:00:00 UTC;</li>
<li>Add a <code>(response-status)</code> pseudo-header, containing the HTTP status code such as <code>200</code> or <code>304</code>;</li>
<li>Compute a Signing HTTP Messages signature over all headers in the cache entry, as well as the pseudo-headers above.</li>
</ul>
<p>The signature for a complete cache entry is generally added to an HTTP response message as an additional header. The variations of this protocol are described in detail in the <a href="#distribution">Distribution</a> section.</p>
<h4 id="stream-signatures"><a class="header" href="#stream-signatures">Stream signatures</a></h4>
<p>In addition to using a signature to cover each complete cache entry, the Ouinet system implements a signature scheme in which a cache entry is split into multiple fragments, and a signature is computed for each separate fragment. When this scheme is used to sign a cache entry for a large resource, a Ouinet client can fetch only the parts of a large resource it is interested in, and verify their legitimacy without first having to download the resource in its entirety.</p>
<p>The streaming of media resources is one major application of this signature scheme, and the design of the scheme is motivated in large part by the wish to support that application. When streaming a large resource using the distributed cache, the Ouinet client can fetch each consecutive fragment of the resource along with the signature for that fragment, verify the signature, and start using the resource data present in the fragment without first having to download the entire resource.</p>
<p>To support this application, the streaming-signatures scheme splits the response body of the cache entry into a sequence of blocks, each consisting of the same number of bytes. It then constructs a <em>Merkle DAG</em> over this block sequence, consisting of a signature for each block that describes the content of the block, as well as a reference to the previous signed block in the sequence. This structure makes it possible to not only verify the legitimacy of the individual blocks, but also to confirm that the sequence of blocks forms a coherent whole.</p>
<p>To construct a signature stream, the injector server computes the following components:</p>
<ul>
<li><code>block-size</code>: The size of each data block, measured as a number of bytes.</li>
<li><code>injection-id</code>: The unique ID of the cache entry, described in the <code>X-Ouinet-Injection</code> response header.</li>
<li><code>header-signature</code>: A signature over the headers of the cache entry. This is computed the same way as the complete cache entry signature described in the previous section, except that the <code>Digest</code> and <code>X-Ouinet-Data-Size</code> headers are absent. This absence makes it possible for the injector server to compute the <code>header-signature</code> before fetching the complete response body.</li>
<li><code>block(i)</code>: The sequence of bytes running from byte <code>i * block-size</code> in the response body, to byte <code>(i + 1) * block-size</code> in the response body. The last block in this sequence may have fewer than <code>block-size</code> bytes.</li>
<li><code>hash(i)</code>: The cryptographic hash of <code>block(i)</code>.</li>
<li><code>chained-hash(i)</code>: The cryptographic hash of <code>block-signature(i - 1) ++ chained-hash(i - 1) ++ hash(i)</code>. <code>block-signature(-1)</code> and <code>chained-hash(-1)</code> are conventionally the empty string.</li>
<li><code>block-signature(i)</code>: The signature of the bytestring <code>injection-id ++ '\0' ++ ascii-decimal(i * block-size) ++ '\0' ++ chained-hash(i)</code>.</li>
<li><code>data-size</code>: The size of the complete response body, measured as a number of bytes.</li>
<li><code>full-signature</code>: The signature of the complete cache entry, as described in the previous section.</li>
</ul>
<p>In the above, the <code>++</code> operator denotes concatenation.</p>
<p>The complete signature stream consists of the <code>block-size</code>, <code>injection-id</code>, <code>header-signature</code>, <code>block-signature</code>, <code>data-size</code>, and <code>full-signature</code> values. The Ouinet client can verify this signature stream by first verifying the <code>header-signature</code> after having received the response header, and then verifying each <code>block-signature(i)</code> after having received <code>block(i)</code>, as well the <code>block-size</code> and <code>injection-id</code> which the client needs to receive before verifying any block signatures. After receiving the final block, the <code>data-size</code> value, and the <code>full-signature</code>, the client can verify that the sequence of blocks it has received together form the complete response body.</p>
<p>For a client to be able to perform the streaming verification of a cache entry as above, the party serving the stream-signed cache entry needs to transmit the different components of a signature stream in a careful order. Ideally, it should send the <code>block-size</code>, <code>injection-id</code>, and <code>header-signature</code> fields before sending any block data; proceed by alternating <code>block(i)</code> and <code>block-signature(i)</code> fields; and finally send the <code>data-size</code> and <code>full-signature</code> fields. Depending on what parts of a cache entry are available, however, other streaming protocols are also possible. This is described in more detail in the <a href="#distribution">Distribution</a> section.</p>
<h4 id="cryptographic-primitives"><a class="header" href="#cryptographic-primitives">Cryptographic primitives</a></h4>
<p>The descriptions in this section, as well as the signature format described in the <a href="https://datatracker.ietf.org/doc/html/draft-cavage-http-signatures-12">Signing HTTP Messages</a> draft, both make use of a cryptographic hash function and a cryptographic signature scheme. These systems are not sensitive to the exact choice of these cryptographic primitives, and they can be selected and replaced based on improvements in cryptography.</p>
<p>The current version of the Ouinet distributed cache uses the following implementations for these primitives:</p>
<ul>
<li>The cryptographic hash of the complete response body stored in the <code>Digest</code> header uses <strong>SHA-256</strong>.</li>
<li>The cryptographic hash used to construct stream signatures uses <strong>SHA-512</strong>.</li>
<li>The cryptographic signature used to compute <code>block-signature(i)</code> uses <strong>Ed25519</strong>.</li>
<li>The Signing HTTP Messages signature uses the <strong>hs2019</strong> signature scheme using the <strong>SHA-512</strong> hash function and <strong>Ed25519</strong> signature scheme.</li>
</ul>
<p>A cache entry signed using implementations of these primitives different from the choices above is likely to be rejected by the current implementation of the Ouinet client. Each of these choices is likely to change in some future version of the Ouinet project.</p>
<h4 id="examples"><a class="header" href="#examples">Examples</a></h4>
<p>An injector server using Ed25519 private key <code>KEY</code> might construct the following as-yet unsigned cache entry:</p>
<pre><code>HTTP/1.1 200 OK
X-Ouinet-Version: 6
X-Ouinet-URI: https://example.com/hello
X-Ouinet-Injection: id=qwertyuiop-12345,ts=1584748800
Date: Sat, 21 Mar 2020 00:00:00 GMT
Content-Type: text/plain

Hello world!
</code></pre>
<p>The injector server would compute a message digest and content length of the <code>Hello world!</code> message body, and add the following headers to the cache entry:</p>
<pre><code>Digest: SHA-256=wFNeS+K3n/2TKRMFQ2v4iTFOSj+uwF7P/Lt98xrZ5Ro=
X-Ouinet-Data-Size: 12
</code></pre>
<p>The injector server would create the following complete cache entry signature:</p>
<pre><code>keyId=&quot;ed25519=&lt;key&gt;&quot;,algorithm=&quot;hs2019&quot;,created=1584748800, headers=&quot;(response-status) (created) x-ouinet-version x-ouinet-uri x-ouinet-injection date content-type digest x-ouinet-data-size&quot;,signature=&quot;&lt;signature-base64&gt;&quot;
</code></pre>
<p>In this signature, <code>&lt;key&gt;</code> stands for the public key associated with the <code>KEY</code> private key, and <code>&lt;signature-base64&gt;</code> is the base64 encoding of the Ed25519 signature of the following string:</p>
<pre><code>(response-status): 200
(created): 1584748800
x-ouinet-version: 6
x-ouinet-uri: https://example.com/hello
x-ouinet-injection: id=qwertyuiop-12345,ts=1584748800
date: Sat, 21 Mar 2020 00:00:00 GMT
content-type: text/plain
digest: SHA-256=wFNeS+K3n/2TKRMFQ2v4iTFOSj+uwF7P/Lt98xrZ5Ro=
x-ouinet-data-size: 12
</code></pre>
<p>Lines in this string are separated by newline <code>\n</code> characters. The string does not begin with or end in a newline character.</p>
<p>The injector server might choose not to create a signature stream for this cache entry, on account of its small size. If for the sake of this example the injector would choose to create a signature stream anyway, using a block size of 5 bytes, it would compute the following values:</p>
<ul>
<li><code>block_size</code>: <code>5</code></li>
<li><code>injection-id</code>: <code>qwertyuiop-12345</code></li>
<li><code>header-signature</code>: <code>keyId=&quot;ed25519=&lt;key&gt;&quot;,algorithm=&quot;hs2019&quot;,created=1584748800, headers=&quot;(response-status) (created) x-ouinet-version x-ouinet-uri x-ouinet-injection date content-type&quot;,signature=&quot;&lt;header-signature-base64&gt;&quot;</code></li>
<li><code>block(0)</code>: <code>Hello</code></li>
<li><code>block(1)</code>: <code> worl</code></li>
<li><code>block(2)</code>: <code>d!</code></li>
<li><code>hash(0)</code>: sha512(<code>Hello</code>) = bytes(<code>3615f80c9d293ed7402687f94b22d58e529b8cc7916f8fac7fddf7fbd5af4cf777d3d795a7a00a16bf7e7f3fb9561ee9baae480da9fe7a18769e71886b03f315</code>)</li>
<li><code>hash(1)</code>: sha512(<code> worl</code>) = bytes(<code>aa82fd4f26829609f65c8a4828f40326897e7099e22f366306fbf870a691e590fa3335eb5e9399511aed5a901adb747feee7fb0198952175c0d8bf4034d45c23</code>)</li>
<li><code>hash(2)</code>: sha512(<code>d!</code>) = bytes(<code>7def752f32053ab9b715d7d3f9364df7a050eb86f88a558a0d42aff49b4671a2dfabde2beb8ad15d69c623e27b8cdfdf3d83bf4249940654b77d6a12bdff125e</code>)</li>
<li><code>chained-hash(0)</code>: sha512(hash(0))</li>
<li><code>block-signature(0)</code> = signature(<code>qwertyuiop-12345</code> <code>\0</code> <code>0</code> <code>\0</code> chained-hash(0))</li>
<li><code>chained-hash(1)</code>: sha512(block-signature(0) ++ chained-hash(0) ++ hash(1))</li>
<li><code>block-signature(1)</code> = signature(<code>qwertyuiop-12345</code> <code>\0</code> <code>5</code> <code>\0</code> chained-hash(1))</li>
<li><code>chained-hash(2)</code>: sha512(block-signature(1) ++ chained-hash(1) ++ hash(2))</li>
<li><code>block-signature(2)</code> = signature(<code>qwertyuiop-12345</code> <code>\0</code> <code>10</code> <code>\0</code> chained-hash(2))</li>
<li><code>data-size</code>: 12</li>
<li><code>full-signature</code>: The complete cache entry signature described above</li>
</ul>
<p>In the computation of <code>header-signature</code> in the above, <code>&lt;key&gt;</code> stands for the public key associated with the <code>KEY</code> private key, and <code>&lt;header-signature-base64&gt;</code> is the base64 encoding of the Ed25519 signature of the following string:</p>
<pre><code>(response-status): 200
(created): 1584748800
x-ouinet-version: 6
x-ouinet-uri: https://example.com/hello
x-ouinet-injection: id=qwertyuiop-12345,ts=1584748800
date: Sat, 21 Mar 2020 00:00:00 GMT
content-type: text/plain
</code></pre>
<p>Of these values, the combination of <code>block-size</code>, <code>injection-id</code>, <code>header-signature</code>, <code>block-signature(0..2)</code>, <code>data-size</code>, and <code>full-signature</code> makes up the complete signature scheme. The way in which these values are communicated to the recipient of this cache entry is described in the <a href="#distribution">Distribution</a> section.</p>
<h2 id="distribution"><a class="header" href="#distribution">Distribution</a></h2>
<p>The Ouinet distributed cache functions as a global distributed repository of cache entries, which different participants in the distributed cache can store in their device's local storage, as well as sharing them between each other. Besides implementing the logic of handling, interpreting, validating, and otherwise making use of such cache entries, as described in detail in the previous section, the Ouinet distributed cache also encompasses a collection of mechanisms by which different participants in the distributed cache can transfer cache entries between themselves.</p>
<p>The primary methods by which cache entries are transmitted between different distributed cache participants are requests from a Ouinet client to an injector server, and the peer-to-peer exchange of cache entries between clients. Clients can send a request to an injector server when they wish to access a resource that is not yet present in the distributed cache; the injector server can then fetch the resource, construct a cache entry based on this fetched resource, and transmit this cache entry to the requesting client. When the distributed cache already contains a cache entry for a particular resource, a client wishing to access that resource can send a peer-to-peer request to some other client that is storing that cache entry in their device storage, and access the resource that way.</p>
<p>Both requests sent by a client to an injector, and the peer-to-peer exchange of cache entries between clients, are systems that use a network connection to transfer cache entries towards a client when that client needs the cached resource. In addition to those methods, the Ouinet distributed cache can also support applications where cache entries are distributed in a more ad-hoc batched manner. These methods play a limited role in the most common applications of the Ouinet system, but have an important supportive function in certain more specialized applications.</p>
<h3 id="injector-to-client-cache-entry-exchange"><a class="header" href="#injector-to-client-cache-entry-exchange">Injector-to-client cache entry exchange</a></h3>
<p>The Ouinet client can send a request to an injector server for the injector to fetch a web resource, and construct a cache entry based on the response that the requesting client can then use and share in the distributed cache. An injector server serves this request by performing an HTTP request, verifying that the response is eligible for caching, constructing a cache entry, signing it, and sending the signed cache entry back to the requesting client.</p>
<p>To perform this procedure, a Ouinet client first establishes a connection to an injector server. The Ouinet system supports a variety of ways in which a client can establish a connection with an injector server; the different ways in which this connection can be established are described in the <a href="#injector-servers">Injector Servers</a> section. These connections all make use of the TLS protocol, by which the client can verify that it is connected to a legitimate injector server using a secure channel.</p>
<p>Once the Ouinet client has established a connection to an injector server, the client can send a request for the injector to create a cache entry. This request is sent as a standard HTTP proxy request, along with an additional HTTP header signifying the intent to create a cache entry. This header distinguishes a cache-entry-creation request from other functionality offered by injector servers, as described in the <a href="#injector-servers">Injector Servers</a> section.</p>
<p>When the injector server has performed the requested HTTP transaction and created a cache entry, it can then send the cache entry to the requesting client as a standard HTTP response. Because cache entries have the form of an HTTP response object combined with some assorted metadata, the injector server can simply send the cache entry as an HTTP response, and add the metadata in the form of additional HTTP headers.</p>
<p>To transport a cache entry as an HTTP response, the injector server may need to add some additional headers that are not part of the cache entry as such, but which are instead used to coordinate the transport process, such as the <code>Content-Length</code>, <code>Transfer-Encoding</code>, and <code>Connection: close</code> headers. Because the cache entry signature specifies exactly which headers are part of the cache entry proper, the receiving client knows exactly which headers are part of the cache control object, and which can be discarded after completion of the HTTP transaction.</p>
<p>The injector server can reply to a cache entry request with three different types of responses: a cache entry with a signature stream, a cache entry with only a signature that covers the complete entry, and a response indicating that no cache entry was created. The injector server uses different response formats for each.</p>
<h4 id="signature-streams"><a class="header" href="#signature-streams">Signature streams</a></h4>
<p>When transmitting a cache entry signed using a signature stream, the injector server needs to communicate the <code>block-size</code>, <code>injection-id</code>, <code>header-signature</code>, <code>block-signature(i)</code>, <code>data-size</code>, and <code>full-signature</code> signature components to the client. It also needs to add the <code>Digest</code> and <code>X-Ouinet-Data-Size</code> headers to the cache entry.</p>
<p>Several of these pieces of information cannot be stored as HTTP headers in the straightforward way without undesirable side effects. The <code>full-signature</code>, <code>Digest</code>, and often the <code>data-size</code> fields are information the injector server only knows after having received the entire resource from the origin server; the different <code>block-signature(i)</code> values each become computable as the resource transfer from the origin server progresses. If the injector server would communicate this information as HTTP headers, which in the HTTP protocol are sent <em>before</em> the response body, the injector server would have to finish the download of the entire resource before beginning to send the cache entry response body to the requesting client. The resulting performance limitations would greatly limit the useful value of signature streams for streaming media content. It would be much preferable for the injector server to send fragments of the response body and elements of the signature stream as each becomes available, enabling the client to fetch and verify the cache entry in streaming form, without any part of the system having to wait for a large download to finish.</p>
<p>To support this behavior, the injector server communicates cache entries with signature streams to the client using the chunked transfer-encoding, storing signature stream fields in HTTP trailers and chunk extensions. This usage of HTTP makes it possible to communicate parts of the metadata in advance of the response body using headers, parts after the response body using trailers, and parts of the metadata interleaved with the response body using chunk extensions.</p>
<p>The chunk extension syntax of HTTP makes it possible for an HTTP stream to contain a set of key-value pairs attached to each response body chunk. This can be used to communicate metadata pertaining to the body chunk to which the key-value pairs are attached, or it can be used to communicate metadata pertaining to the response body as a whole, without the key-value pairs having any direct association with the body chunk to which they are attached. The distributed cache uses chunk extensions in the latter way, attaching a key-value pair for each <code>block-signature</code> field at the earliest opportunity.</p>
<p>When transmitting a cache entry using a signature stream, the injector server adds the following pieces of metadata to the HTTP response to communicate the signature stream fields:</p>
<ul>
<li>A <code>Digest</code> trailer containing the full message digest. This digest can only be computed after the injector has received the entire response body, and therefore is stored in a trailer.</li>
<li>An <code>X-Ouinet-Data-Size</code> header, or trailer, containing the <code>data-size</code> field. This field can have the form of a header or a trailer, depending on the time at which the injector first learns this value.</li>
<li>An <code>X-Ouinet-Sig0</code> header containing the <code>header-signature</code>;</li>
<li>An <code>X-Ouinet-BSigs</code> header, containing the <code>block-size</code> as well as the cryptographic parameters used to compute the <code>block-signature</code> values. Encoded as <code>X-Ouinet-BSigs: keyId=&quot;&lt;key&gt;&quot;,algorithm=&quot;&lt;algorithm&gt;&quot;,size=&lt;block-size&gt;</code>, where <code>&lt;key&gt;</code> is the public key used to sign the block signatures; <code>&lt;algorithm&gt;</code> is the algorithm used to sign the block signatures; and <code>&lt;block-size&gt;</code> is the <code>block-size</code> as an integer value.</li>
<li>An <code>X-Ouinet-Sig1</code> trailer containing the <code>full-signature</code>;</li>
<li>A series of <code>ouisig=&lt;signature&gt;</code> chunk extensions, containing the different <code>block-signature(i)</code> values. These chunk extensions all use <code>ouisig</code> as a name, and are sent in increasing order; that is, the <code>i</code>th <code>ouisig</code> chunk extension contains <code>block-signature(i)</code>. <code>&lt;signature&gt;</code> is encoded as the base64 encoding of the block signature.</li>
</ul>
<p>A client receiving a cache entry containing a signature stream can recognize this response type by the presence of the <code>X-Ouinet-BSigs</code> header, and handle it accordingly. A client that wishes not to implement streaming for this particular resource can choose to ignore the metadata specific to signature streams, and make use only of the <code>Digest</code>, <code>X-Ouinet-Data-Size</code>, and <code>X-Ouinet-Sig1</code> headers, and treat the response as if it were signed only using a complete cache entry signature instead.</p>
<h4 id="complete-cache-entry-signatures"><a class="header" href="#complete-cache-entry-signatures">Complete cache entry signatures</a></h4>
<p>A cache entry that is signed only with a complete cache entry signature only contains the <code>Digest</code>, <code>X-Ouinet-Data-Size</code>, and <code>full-signature</code> signature fields that need to be communicated to the client by the injector server. The Ouinet injector communicates this using a simplified form of the signature streams format, in which only the <code>Digest</code>, <code>X-Ouinet-Data-Size</code>, and <code>X-Ouinet-Sig1</code> headers are present. Each of those headers may take the form of either a header or a trailer.</p>
<p>A client receiving such a cache entry can recognize this response type by the presence of the <code>X-Ouinet-Sig1</code> header, combined with the absence of the <code>X-Ouinet-BSigs</code> header. This combination indicates that the cache entry can only be verified in its complete form, and streaming verification is not possible.</p>
<h4 id="error-responses"><a class="header" href="#error-responses">Error responses</a></h4>
<p>When an injector server is requested to create a cache entry for a resource, and such a cache entry cannot be created -- because the resource is not eligible for caching, indicates an error response, or perhaps because the resource could not be retrieved at all -- the injector server sends an HTTP response to the client that does not contain any of the signature headers described above. When a client receives a response containing neither the <code>X-Ouinet-Sig1</code> or <code>X-Ouinet-Sig0</code> headers, this reply can be served to the user application as normal, but it cannot be stored in the distributed cache.</p>
<h4 id="examples-1"><a class="header" href="#examples-1">Examples</a></h4>
<p>An injector server transmitting the example cache entry described at the end of the <a href="#cache-structure">Cache structure</a> section to a client might send the following HTTP response:</p>
<pre><code>HTTP/1.1 200 OK
X-Ouinet-Version: 6
X-Ouinet-URI: https://example.com/hello
X-Ouinet-Injection: id=qwertyuiop-12345,ts=1584748800
Date: Sat, 21 Mar 2020 00:00:00 GMT
Content-Type: text/plain
X-Ouinet-Sig0: keyId=&quot;ed25519=&lt;key&gt;&quot;,algorithm=&quot;hs2019&quot;,created=1584748800, headers=&quot;(response-status) (created) x-Ouinet-version x-Ouinet-uri x-Ouinet-injection date content-type&quot;,signature=&quot;&lt;header-signature-base64&gt;&quot;
X-Ouinet-BSigs: keyId=&quot;ed25519=&lt;key&gt;&quot;,algorithm=&quot;hs2019&quot;,size=5
Transfer-Encoding: chunked
Trailer: Digest, X-Ouinet-Data-Size, X-Ouinet-Sig1

5
Hello
5;ouisig=&lt;base64(block-signature(0))&gt;
 worl
2;ouisig=&lt;base64(block-signature(1))&gt;
d!
0;ouisig=&lt;base64(block-signature(2))&gt;
Digest: SHA-256=wFNeS+K3n/2TKRMFQ2v4iTFOSj+uwF7P/Lt98xrZ5Ro=
X-Ouinet-Data-Size: 12
X-Ouinet-Sig1: keyId=&quot;ed25519=&lt;key&gt;&quot;,algorithm=&quot;hs2019&quot;,created=1584748800, headers=&quot;(response-status) (created) x-Ouinet-version x-Ouinet-uri x-Ouinet-injection date content-type digest x-Ouinet-data-size&quot;,signature=&quot;&lt;full-signature-base64&gt;&quot;

</code></pre>
<p>If the injector server decided to only create a complete cache entry signature, it might instead send the following HTTP response:</p>
<pre><code>HTTP/1.1 200 OK
X-Ouinet-Version: 6
X-Ouinet-URI: https://example.com/hello
X-Ouinet-Injection: id=qwertyuiop-12345,ts=1584748800
Date: Sat, 21 Mar 2020 00:00:00 GMT
Content-Type: text/plain
Transfer-Encoding: chunked
Trailer: Digest, X-Ouinet-Data-Size, X-Ouinet-Sig1

12
Hello world!
0
Digest: SHA-256=wFNeS+K3n/2TKRMFQ2v4iTFOSj+uwF7P/Lt98xrZ5Ro=
X-Ouinet-Data-Size: 12
X-Ouinet-Sig1: keyId=&quot;ed25519=&lt;key&gt;&quot;,algorithm=&quot;hs2019&quot;,created=1584748800, headers=&quot;(response-status) (created) x-Ouinet-version x-Ouinet-uri x-Ouinet-injection date content-type digest x-Ouinet-data-size&quot;,signature=&quot;&lt;full-signature-base64&gt;&quot;

</code></pre>
<p>When sending only a complete cache signature like the example above, the injector server might also avoid chunked transfer encoding entirely, and send the following response:</p>
<pre><code>HTTP/1.1 200 OK
X-Ouinet-Version: 6
X-Ouinet-URI: https://example.com/hello
X-Ouinet-Injection: id=qwertyuiop-12345,ts=1584748800
Date: Sat, 21 Mar 2020 00:00:00 GMT
Content-Type: text/plain
Content-Length: 12
Digest: SHA-256=wFNeS+K3n/2TKRMFQ2v4iTFOSj+uwF7P/Lt98xrZ5Ro=
X-Ouinet-Data-Size: 12
X-Ouinet-Sig1: keyId=&quot;ed25519=&lt;key&gt;&quot;,algorithm=&quot;hs2019&quot;,created=1584748800, headers=&quot;(response-status) (created) x-Ouinet-version x-Ouinet-uri x-Ouinet-injection date content-type digest x-Ouinet-data-size&quot;,signature=&quot;&lt;full-signature-base64&gt;&quot;

Hello world!

</code></pre>
<p>Of these three examples, the last two would be considered equivalent by a recipient client. The client would recognize the first example as being semantically equivalent to the last two, but it would be able to stream the resource content incrementally while still downloading the remainder of the content simultaneously.</p>
<h3 id="peer-to-peer-cache-entry-exchange"><a class="header" href="#peer-to-peer-cache-entry-exchange">Peer-to-peer cache entry exchange</a></h3>
<p><strong>TODOv6 INCOMPLETE(multi-peer)</strong></p>
<p>When a Ouinet client stores a collection of cache entries in its device local storage, it can share these cache entries with other users that wish to access them. By fetching cache entries from other users in this way, without involvement of the injector servers, a Ouinet client can access web content even in cases when it cannot reach the injector servers.</p>
<p>A Ouinet client willing to share its cache entries with others can serve HTTP requests using a protocol very similar to that used by the injector servers. Unlike injector servers, a Ouinet client participating in the distributed cache will only respond to such requests by serving a copy of a cache entry it has stored in its local device storage. Using this system, a client wishing to fetch a cached resource from another client that stores a cache entry for that resource can establish a peer-to-peer connection to that client, send an HTTP request for the cached resource, and retrieve the cache entry. The recipient can then verify the legitimacy of the cache entry, use the resource in a user application, and optionally store the resource in its own local storage.</p>
<p>By this mechanism, Ouinet clients can fetch cache entries from other Ouinet clients that store a copy of the cache entry in their local storage. For this to function as a distributed cache, however, it is not sufficient for a Ouinet client to be able to fetch resources from other clients that store it; a client attempting to gain access to a web resource also needs some way to determine <em>which</em> users hold such cache entries, as well as details on how to establish a connection to these clients. Only with such a mechanism can a Ouinet client obtain access to a web resource by acquiring a list of other clients that hold a cached copy of the resource, connect to one such client, and fetch a copy of a cache entry describing that resource.</p>
<p>The Ouinet distributed cache uses a distributed hash table to store this index information in a distributed way. Using this distributed hash table, clients that store a particular cache entry and are willing to share this cache entry with others can announce this fact in the global distributed hash table. Clients that wish to access a certain resource using the distributed cache can query the distributed hash table for a list of clients that share it, and then proceed to connect to one or several of such clients in an attempt to fetch the cache entry for their own use.</p>
<h4 id="peer-to-peer-connections"><a class="header" href="#peer-to-peer-connections">Peer-to-peer connections</a></h4>
<p>When a Ouinet client wishes to share its stored cache entries with other clients, it can open a server socket using the <a href="http://bittorrent.org/beps/bep_0029.html">uTP protocol</a>, and publish the IP address and UDP port on which they are listening in the distributed hash table. Clients wishing to download cache entries from them can connect to this socket. Once a connection is established, the connecting client can request cache entries using the HTTP protocol, as described in the next section.</p>
<p>The uTP protocol is rarely blocked by network operators, due to its association with the BitTorrent system. For this reason, it is a more suitable choice in the Ouinet project for a stream-oriented peer-to-peer protocol than alternatives such as TCP. Additionally, the uTP protocol has several characteristics that make it particularly reliable in networks that are restricted by the limitations of NAT routing, which makes it a good choice for peer-to-peer communication on mobile devices.</p>
<h4 id="cache-entry-requests"><a class="header" href="#cache-entry-requests">Cache entry requests</a></h4>
<p>When a client wishing to fetch a cache entry has established a peer-to-peer connection to a client that has such a cache entry in storage, it can then start sending HTTP requests over this connection. The sharing client can respond to these requests by serving a stored cache entry as a response, or it can respond with an error message if it does not store such a cache entry.</p>
<p>A cache entry HTTP request sent over a peer-to-peer connection between two Ouinet clients must have the form of a GET or HEAD request, and use a request URI specified in absolute form; that is, the HTTP request must use a full URI on the first line of the HTTP request, which includes a protocol specification and a hostname. Any <code>Host</code> headers present in the HTTP request are ignored. The HTTP request must include an <code>X-Ouinet-Version</code> header, describing the version of the Ouinet protocol in use; any other headers in the HTTP request that are not described in this section are ignored by the sharing Ouinet client.</p>
<p>When a Ouinet client sharing cache entries over a peer-to-peer connection receives such a request, it can reply with one of the three response types specified in the <a href="#injector-to-client-cache-entry-exchange">Injector-to-client cache entry exchange</a> section. If the client stores a cache entry for the requested URI, and that cache entry is signed using a signature stream, the client can send a signature stream response. If the client stores a cache entry for the requested URI which only contains a complete cache entry signature, the client can send a complete cache entry signature response. If the client does not store any cache entries for the requested URI, it must reply with an HTTP reply using the <code>404 Not Found</code> status code.</p>
<p>If the client sharing a cache entry sends an HTTP response containing a cache entry stored in its local storage, it generally knows the contents of the <code>Digest</code>, <code>X-Ouinet-Data-Size</code>, and <code>X-Ouinet-Sig1</code> headers before starting transmission of the cache entry. In this case, it may choose to send these fields as HTTP headers instead of trailers.</p>
<h4 id="range-requests"><a class="header" href="#range-requests">Range requests</a></h4>
<p>When a Ouinet client stores a cache entry signed using a signature stream, it can transfer fragments of the cached resource to a recipient client, who can then verify that these fragments form part of a legitimate cache entry without holding a copy of the complete cache entry. Besides streaming media resources from the distributed cache by fetching and verifying consecutive blocks of resource data, this structure also makes it possible for a client to fetch and verify a fragment in the <em>middle</em> of a large resource. This functionality can be used by clients to fetch a small part of a larger resource, or to resume downloading a cache entry from one client after having fetched parts of the entry from a different client.</p>
<p>The Ouinet client implements this functionality in peer-to-peer connections through the mechanism of HTTP range requests. A client can send a cache entry HTTP request containing the <code>Range</code> header, requesting that the responding client sends it only the fragment of the resource delineated by this range; for example, a client might request the second unit of thousand bytes by sending the <code>Range: bytes=1000-1999</code> request header. If the responding client stores a cache entry for the requested resource signed using a signature stream, it can respond by sending only those resource data blocks that cover this byte range, along with block signatures for those data blocks. If the requested byte range does not align to the block size, the responding client has to send somewhat more data than was requested, rounded up to the nearest block size boundary.</p>
<p>For a client to verify the legitimacy of a sequence of consecutive blocks that do not include the first block in the resource, it is not sufficient for the client to hold the block signatures for those blocks. Because each block signature contains (via the block's chained hash) a reference to the signature and chained hash of the previous block, the verifying client additionally needs to hold the chained hash of the block immediately preceeding the first block it wishes to verify, unless the first block it wishes to verify is also the first block in the resource. That is to say, if a client holds <code>block(i)</code>, <code>block(i + 1)</code>, ..., <code>block(j)</code>, for <code>0 &lt; i &lt;= j</code>, it needs <code>block-signature(i)</code>, <code>block-signature(i + 1)</code>, ... <code>block-signature(j)</code>, as well as <code>block-signature(i - 1)</code> and <code>chained-hash(i - 1)</code> to be able to perform a verification of this signature stream. To make this possible, a client responding to a range request with a partial content response will add these preceeding signature and hash to the HTTP response, in the form of additional chunk extensions.</p>
<p>A client receiving a range request for a cache entry can reply with a response containing that partial data, as described above, if it has the facilities and metadata to do so; if it does not, it can send a response containing the complete resource, as if the <code>Range</code> header were not present at all. If it does reply with a response containing partial data, the client will send a response structured as a variant of the regular signature stream response, to which the following modifications apply:</p>
<ul>
<li>A partial data response uses HTTP status code <code>206 Partial Content</code>. This indicates to the recipient that the response contains partial data.</li>
<li>The response contains a <code>Content-Range</code> header, describing the resource fragment included in the response. This range may be broader than the requested range, to ensure the range is aligned to the block boundary. A partial data response may include multiple ranges.</li>
<li>The response contains an additional <code>X-Ouinet-HTTP-Status</code> header, containing the status code of the response that would have been sent if no <code>Range</code> was requested, denoted as an integer value. The recipient requires this original status code to be able to verify the cache entry signature, and will substitute it when performing this verification.</li>
<li>The response contains one <code>ouisig</code> chunk extension for each data block included in the resource fragment, in the order that those data blocks are transferred, containing the block signatures for those blocks. Block signatures for blocks that are not covered by the response are not included.</li>
<li>The response contains one <code>ouipsig=&lt;signature&gt;</code> and <code>ouihash=&lt;hash&gt;</code> chunk extension for each separate range described in the <code>Content-Range</code> header, except for those ranges that contain the first block in the resource, in the same order as the ranges described in the <code>Content-Range</code> header. For each range described in the <code>Content-Range</code> header that covers the fragment of the resource from <code>block(i)</code> up to <code>block(j)</code>, the <code>&lt;signature&gt;</code> and <code>&lt;hash&gt;</code> contain <code>block-signature(i - 1)</code> and <code>chained-hash(i - 1)</code> respectively, both in base64 encoding.</li>
</ul>
<h4 id="examples-2"><a class="header" href="#examples-2">Examples</a></h4>
<p>A client wishing to fetch only the second half of the example cache entry described at the end of the <a href="#cache-structure">Cache structure</a> section might send the following peer-to-peer cache entry request to a different client:</p>
<pre><code>GET https://example.com/hello HTTP/1.1
X-Ouinet-Version: 6
Range: bytes=6-11

</code></pre>
<p>If the receiving client contains a cache entry for this resource signed using a signature stream, it might send the following reply:</p>
<pre><code>HTTP/1.1 206 Partial Content
X-Ouinet-Version: 6
X-Ouinet-URI: https://example.com/hello
X-Ouinet-Injection: id=qwertyuiop-12345,ts=1584748800
Date: Sat, 21 Mar 2020 00:00:00 GMT
Content-Type: text/plain
X-Ouinet-Sig0: keyId=&quot;ed25519=&lt;key&gt;&quot;,algorithm=&quot;hs2019&quot;,created=1584748800, headers=&quot;(response-status) (created) x-Ouinet-version x-Ouinet-uri x-Ouinet-injection date content-type&quot;,signature=&quot;&lt;header-signature-base64&gt;&quot;
X-Ouinet-BSigs: keyId=&quot;ed25519=&lt;key&gt;&quot;,algorithm=&quot;hs2019&quot;,size=5
Digest: SHA-256=wFNeS+K3n/2TKRMFQ2v4iTFOSj+uwF7P/Lt98xrZ5Ro=
X-Ouinet-Data-Size: 12
X-Ouinet-Sig1: keyId=&quot;ed25519=&lt;key&gt;&quot;,algorithm=&quot;hs2019&quot;,created=1584748800, headers=&quot;(response-status) (created) x-Ouinet-version x-Ouinet-uri x-Ouinet-injection date content-type digest x-Ouinet-data-size&quot;,signature=&quot;&lt;full-signature-base64&gt;&quot;
Transfer-Encoding: chunked
Content-Range: bytes 5-11/12
X-Ouinet-HTTP-Status: 200

5;ouipsig=&quot;&lt;base64(block-signature(0))&gt;&quot;;ouihash=&quot;&lt;base64(chained-hash(0))&gt;&quot;
 worl
2;ouisig=&lt;base64(block-signature(1))&gt;
d!
0;ouisig=&lt;base64(block-signature(2))&gt;

</code></pre>
<h4 id="distributed-hash-table"><a class="header" href="#distributed-hash-table">Distributed hash table</a></h4>
<p>When a Ouinet client stores a cache entry for a particular resource and is willing to share it with others, it needs to communicate this fact to other users that might be interested in accessing this cache entry. After all, a client wishing to fetch this cache entry can only do so if it knows where the entry is to be found. For the same reason, the client storing the entry needs to communicate the address by which it can be reached.</p>
<p>The Ouinet distributed cache uses the BitTorrent distributed hash table as a structure for communicating this information. The BitTorrent distributed hash table is a distributed structure traditionally used by the BitTorrent system to store information on which users share pieces of which BitTorrent files; the Ouinet distributed cache uses it in a similar fashion, and uses it to store which Ouinet clients are sharing which cache entries.</p>
<p>When a Ouinet client stores a particular cache entry on its device storage, and is willing to share it with others using a peer-to-peer connection, it sends an announcement message to the BitTorrent distributed hash table containing the IP address and port by which other clients can establish a peer-to-peer connection with the client. This announcement message is addressed to the distributed hash table location consisting of a hash of the URI of the resource contained in the cache entry. Clients wishing to fetch a cache entry for a particular URI can send a request to the BitTorrent distributed hash table, addressed to the distributed hash table location consisting of that same hash, requesting a list of IP addresses and port numbers of clients that have sent such an announcement message. After receiving such a list from the distributed hash table, the client can then establish a peer-to-peer connection to one of the IP addresses listed in the reply, and start requesting cache entries.</p>
<p>The list of Ouinet clients that are sharing a particular cache entry using the peer-to-peer system is stored at a distributed hash table location that is based on the URI of the resource contained in the cache entry, as well as the injector server that created the cache entry. This location is computed as the SHA1 hash of the string <code>ed25519:&lt;public-key&gt;/v&lt;protocol-version&gt;/uri/&lt;uri&gt;</code>, where <code>&lt;public-key&gt;</code> is the public key of the injector server used to sign the cache entry, encoded using lower-case unpadded base32; <code>&lt;protocol-version&gt;</code> is the version of the Ouinet protocol; and <code>&lt;uri&gt;</code> is the URI of the resource contained in the cache entry.</p>
<h4 id="resource-groups"><a class="header" href="#resource-groups">Resource groups</a></h4>
<p>In some applications of the Ouinet distributed cache, clients frequently store significant numbers of cache entries that are all related to each other. For example, a web browser making use of the Ouinet client library might store a cache entry for a web page, as well as several dozens of cache entries for the different media files referred to by that web page. In a web browser application, this behavior is often statistically reliable: almost every user storing a cache entry for a given web page will also store cache entries for linked resources, because the web browser has loaded those resources on each user's device.</p>
<p>In such cases, the clients holding these cache entries will have to send and periodically repeat announcements to the distributed hash table for dozens, if not hundreds, of separate resources. This maintenance traffic required to participate in the distributed hash table can be a nontrivial drain on resources. What is more, this usage of the distributed hash table is unnecessarily inefficient, for the distributed hash table will store very nearly identical lists of Ouinet clients for each of those dozens or hundreds of resources.</p>
<p>To avoid this inefficiency, the user application making use of the Ouinet client library can instruct the client library to combine the registrations in the distributed hash table for all these related cache entries into a single registration. To do so, the user application would specify a <em>resource group</em> for this collection of resources; if such a resource group is specified, the Ouinet client will not send an announcement to the distributed hash table for each stored cache entry in the resource group, but will instead send a single announcement to the distributed hash table location consisting of a hash of the resource group description. Clients wishing to access resources in this resource group would need to configure the same resource group on their devices, and send a request for connectivity information to the distributed hash table addressed to the hash of the resource group instead. As an example, a web browser application using the Ouinet client library might configure a resource group for each web page, containing the web page itself as well as all resources referenced from that web page.</p>
<p>If registrations for a group of cache entries are announced to the distributed hash table using a resource group, announcements and client requests for those resources are addressed to a location in the distributed hash table that is based on the resource group, rather than on the URI of the individual resources. This location is computed as the SHA1 hash of the string <code>ed25519:&lt;public-key&gt;/v&lt;protocol-version&gt;/uri/&lt;resource-group&gt;</code>, where <code>&lt;public-key&gt;</code> is the public key of the injector server used to sign the cache entries, encoded using lower-case unpadded base32; <code>&lt;protocol-version&gt;</code> is the version of the Ouinet protocol; and <code>&lt;resource-group&gt;</code> is the resource group bytestring specified by the application.</p>
<p>The Ouinet client can only fetch resources collected into a resource group if clients storing cache entries in the resource group can be relied on to store cache entries for <em>all</em> resources in the resource group, the majority of the time. If a substantial number of clients store only a limited subset of the resources collected in the resource group, a client trying to fetch such a resource stands a good chance of accidentally connecting to a client that does store some cache entry in the resource group, but not the entry the client is interested in. Therefore, the Ouinet client does not attempt to identify resource groups automatically, and instead relies on a user application to configure resource groups, if applicable.</p>
<h3 id="out-of-band-cache-entry-exchange"><a class="header" href="#out-of-band-cache-entry-exchange">Out of band cache entry exchange</a></h3>
<p>In addition to transferring cache entries between different participants in the distributed cache using a network connection, applications using the Ouinet system can also distribute cache entries in more ad-hoc ways, such as by distributing storage devices containing collections of cache entries. Techniques such as this do not play a role in the primary application of the Ouinet system, but can be applicable to more specialist applications. The different ways in which such techniques could be arranged logistically are not specified in further detail in this document.</p>
<h4 id="cache-exchange-format"><a class="header" href="#cache-exchange-format">Cache exchange format</a></h4>
<p>To circulate cached content out of band, formats for data at rest are defined.  A <em>static cache repository</em> is a directory consisting of two subdirectories:</p>
<ul>
<li>One to hold cache entries; for version 3 of the signed HTTP storage format, this is called <code>data-v3</code>.</li>
<li>One to hold resource group information; for version 0 of the DHT group storage format, this is called <code>dht_groups</code>.</li>
</ul>
<p>Each resource group with a distinctive bytestring <code>&lt;resource-group&gt;</code> has a group directory named <code>dht_groups/&lt;lower-hex(sha1(resource-group))&gt;</code> containing:</p>
<ul>
<li>A <code>group_name</code> file with <code>&lt;resource-group&gt;</code> as its only content (no trailing newline).</li>
<li>An <code>items</code> subdirectory with one file per cache entry having that belongs to the group; the file contains the entry's <code>&lt;resource-uri&gt;</code> as its only content (no trailing newline) and is named <code>&lt;lower-hex(sha1(resource-uri))&gt;</code>.</li>
</ul>
<p>Each cache entry with a <code>&lt;resource-uri&gt;</code> and thus <code>&lt;uri-hash=lower-hex(sha1(resource-uri))&gt;</code> has a directory named <code>data-v3/&lt;uri-hash[0:2]&gt;/&lt;uri-hash[2:]&gt;</code>. The splitting of the directory name avoids having too many entries directly under <code>data-v3</code>. The entry's directory contains:</p>
<ul>
<li>A <code>head</code> file holding the whole raw HTTP head with response status and headers (except framing), and <code>X-Ouinet-*</code> headers conforming its signature (as described in the <a href="#signature-computation">Signature computation</a> section). Lines are CRLF-terminated and a final empty line is included.</li>
<li>If the resource has a non-empty body, a <code>sigs</code> file with one fixed-width, LF-terminated line per data block. The i-th line corresponds to the i-th block and has this content: <code>&lt;padded-offset(i)&gt; &lt;base64(block-signature(i))&gt; &lt;base64(hash(i))&gt; &lt;base64(chained-hash(i-1))&gt;</code>, where <code>padded-offset(i)</code> is the offset of the block in lower-case hexadecimal zero-padded to 16 characters, separators are a single space, and hashes and signatures are those defined in the <a href="#stream-signatures">Stream signatures</a> section; <code>chained-hash(-1)</code> is defined as a hash-length string of NUL bytes.</li>
<li>If the resource has a non-empty body, a <code>body</code> file with the raw body data. Alternatively, a <code>body-path</code> can be provided with the path of the body data file relative to the cache root (see below), with forward slashes as path separators and non-ASCII characters encoded using UTF-8 (no <code>.</code> or <code>..</code> components and no trailing new line).</li>
</ul>
<p>The <em>static cache root</em> is a directory containing plain data files optionally pointed to by cache entries. This allows a user in possession of such directory to browse data files arranged in an accessible hierarchy with human-readable names.</p>
<p>Although a static cache repository and root may be completely independent, the former is conventionally named <code>.ouinet</code> and contained directly under the later to ease their conveying.# Distributed Cache</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../how/content.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../how/injectors.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../how/content.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../how/injectors.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
